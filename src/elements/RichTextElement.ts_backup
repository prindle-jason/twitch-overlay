import { TransformElement } from "./TransformElement";
import { sanitizeText } from "../utils/textSanitizer";
import { measureText } from "../utils/canvasUtils";

interface EmoteData {
  name: string;
  url: string;
  start: number;
  end: number;
}

interface RichTextConfig {
  fontSize?: number;
  color?: string;
  font?: string;
  fontWeight?: string;
  textBaseline?: CanvasTextBaseline;
  textAlign?: CanvasTextAlign;
  // strokeColor?: string;
  // strokeWidth?: number;
  emoteHeight?: number;
  emotePadding?: number;
  opacity?: number;
}

interface TextSegment {
  type: "text" | "emote";
  content: string;
  width: number;
  image?: HTMLImageElement;
}

export class RichTextElement extends TransformElement {
  text: string;
  emoteData: EmoteData[];
  font: string;
  fontSize: number;
  color: string;
  fontWeight: string;
  textAlign: CanvasTextAlign;
  textBaseline: CanvasTextBaseline;
  emoteHeight: number;
  emotePadding: number;

  private segments: TextSegment[] = [];
  private width: number = 0;
  private height: number = 0;

  constructor(
    text: string,
    emoteData: EmoteData[] = [],
    config: RichTextConfig = {}
  ) {
    super();
    this.text = sanitizeText(text || "");
    this.emoteData = emoteData || [];
    this.font = config.font ?? "Arial";
    this.fontSize = config.fontSize ?? 24;
    this.color = config.color ?? "#ffffff";
    this.fontWeight = config.fontWeight ?? "normal";
    this.textAlign = config.textAlign ?? "center";
    this.textBaseline = config.textBaseline ?? "middle";
    this.emoteHeight = config.emoteHeight ?? this.fontSize;
    this.emotePadding = config.emotePadding ?? 2;

    this.opacity = config.opacity ?? 1;

    this.segments = this.parseTextWithEmotes();
    this.width = this.calculateWidth();
    this.height = Math.max(this.fontSize, this.emoteHeight);
  }

  private parseTextWithEmotes(): TextSegment[] {
    if (!this.emoteData || this.emoteData.length === 0) {
      return [{ type: "text", content: this.text, width: 0 }];
    }

    const sortedEmotes = [...this.emoteData].sort((a, b) => a.start - b.start);
    const segments: TextSegment[] = [];
    let currentPos = 0;

    for (const emote of sortedEmotes) {
      if (currentPos < emote.start) {
        const textContent = this.text.substring(currentPos, emote.start);
        if (textContent) {
          segments.push({ type: "text", content: textContent, width: 0 });
        }
      }

      const emoteImage = new Image();
      emoteImage.crossOrigin = "anonymous";
      emoteImage.src = emote.url;

      segments.push({
        type: "emote",
        content: emote.name,
        width: this.emoteHeight,
        image: emoteImage,
      });

      currentPos = emote.end + 1;
    }

    if (currentPos < this.text.length) {
      const textContent = this.text.substring(currentPos);
      if (textContent) {
        segments.push({ type: "text", content: textContent, width: 0 });
      }
    }

    return segments;
  }

  private calculateWidth(): number {
    const fontString = this.getFontString();
    let totalWidth = 0;

    for (const segment of this.segments) {
      if (segment.type === "text") {
        segment.width = measureText(segment.content, fontString);
        totalWidth += segment.width;
      } else if (segment.type === "emote") {
        totalWidth += this.emoteHeight + this.emotePadding * 2;
      }
    }

    return totalWidth;
  }

  private getFontString(): string {
    return `${this.fontWeight} ${this.fontSize}px ${this.font}`;
  }

  override getWidth(): number {
    return this.width;
  }

  override getHeight(): number {
    return this.height;
  }

  draw(ctx: CanvasRenderingContext2D): void {
    if (this.opacity <= 0) return;

    ctx.save();
    ctx.globalAlpha = this.opacity;
    ctx.font = this.getFontString();
    ctx.fillStyle = this.color;
    ctx.textBaseline = this.textBaseline;

    let startX = this.x;
    if (this.textAlign === "center") {
      startX = this.x - this.getWidth() / 2;
    } else if (this.textAlign === "right") {
      startX = this.x - this.getWidth();
    }

    let currentX = startX;

    for (const segment of this.segments) {
      if (segment.type === "text") {
        ctx.fillText(segment.content, currentX, this.y);
        currentX += segment.width;
      } else if (segment.type === "emote" && segment.image) {
        currentX += this.emotePadding;

        if (segment.image.complete && segment.image.naturalWidth > 0) {
          const emoteY =
            this.textBaseline === "middle"
              ? this.y - this.emoteHeight / 2
              : this.y;

          ctx.drawImage(
            segment.image,
            currentX,
            emoteY,
            this.emoteHeight,
            this.emoteHeight
          );
        } else {
          ctx.save();
          ctx.fillStyle = "#ff69b4";
          ctx.fillText(segment.content, currentX, this.y);
          ctx.restore();
        }

        currentX += this.emoteHeight + this.emotePadding;
      }
    }

    ctx.restore();
  }
}
